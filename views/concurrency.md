# Многозадачность

В системе существует несколько точек конкурентного взаимодействия.

## Регистрация пользователя

В системе не может существовать более одного пользователя с одним номером телефона и емейлом. При этом пользовательские данные распределены географически. Потенциально возможна ситуация, когда пользователь региструруется с емейлом X на узле A, но этот емейл уже зарегистрирован на узле B.

Для решения этой проблемы мы используем отдельный сервис проверки уникальности email и номера телефона. Данные, которые он использует также будут распределены по нескольким узлам, но теперь каждый регион имеет полный комплект данных. Храниться они должны в виде хэшей и доступ к ним должнен быть максимально быстрым.

При регистрации нового пользователя, идентифицирующие его контакты отправляются в сервис-координатор, который вносит их в сервисы идентификаторы.


![Обеспечение уникальности контактов пользователя](https://raw.githubusercontent.com/ariverrun/coursework/main/assets/contact.uniquenes.approach.png "Обеспечение уникальности контактов пользователя")

## Резервирование товара за пользователем

Нам важно избежать ситуации, когда система позволяет пользователям купить больше товаров чем есть на складах. Кроме того, нужно сделать так, чтобы товар не оказывался продан, за то время как пользователь добавил его в корзину и вводил данные о доставке или делал что-то другое.

Для этого товары должны резервировать на складе за пользователем когда он добавляет их в корзину. После того, как пользователь оплачивает заказ, товары окончательно закрепляются за заказом. Если заказ не был оплачен, заказ отменяется через 24 часа. Если товар был добавлен в корзину, но заказ не был создан, товар отвязывается от пользователя через час (товар остается в корзине, но при попытке создать заказ снова резервируется, если он уже недоступен, выводится уведомление о том, что товар продан).

Конкурентность резервирования товаров реализуется за счет блокировок на уровне базы данных сервиса склада. Здесь не играет роль распределенность системы, так как склад всегда относится к какому-то одному Processing Unit.

