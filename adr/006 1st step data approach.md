# Подход к работе с данными на первом этапе

## Контекст:

Мы выделили 6 сервисов, каждый из которых должен иметь свое хранилище, эти серисы находятся в рамках одного Process Unit. Данные, как и запросы пользователей, должны быть распределены географически. Также мы должны как-то обрабатывать ситуации, когда пользователь переходит из одной зоны в другую, причем для жителей приграничных зон между регионами это переключение может происходить несколько раз в день. Также одни данные чаще считываются, другие записываются, одни данные нужны часто, другие редко.

Можно хранить полную копию данных для каждого Process Unit, но тогда мы потеряем все приемущества выбранного подхода. Можно обращаться к данным других Process Unit, но это также лишит систему всех приемуществ, к которым мы стремимся. Можно хранить только тот набор данных, что относится к Process Unit, а недостающие данные реплицировать "по требованию". 

## Решение

Каждый из выделенных сервисов имеет локальное реляционное хранилище. Часть данных поддерживается в одинаковом состоянии во всех Process Unit, это - все данные сервиса Training, типы метрик, списки видов спорта. Остальные данные разделены географически. 

Ряд данных реплицируется в In-Memory-Data-Grid, а именно: данные сервиса Training, типы метрик, списки видов спорта, выданные авторизационные токены.

При этом каждый Process Unit имеет свой уникальный идентификатор, который возвращается с HTTP заголовке ответа пользователю при авторизации, а затем последний передает его при каждом запросе. В случае, если пользователь попадает на другой Process Unit, то это будет видно по несовпадающему идентификатору и данные частично синхронно будут запрошены у предыдущего юнита, частично асинхронно отреплицированы.

## Статус:

принято

## Последствия:

1. Удастся уменьшить количество данных, хранимых каждым Process Unit и повысить среднюю скорость работы с ними.
2. Удастся повысить скорость работы с теми данными, что используются для тренировок (тот раздел системы, что должен работать наиболее быстро) и чистично аутентификации за счет переноса их в оперативную память.
3. Удастся решить проблему смены Process Unit во время использования пользователем приложения.
4. Подход с получением данных у того Process Unit, что последний обрабатывал запросы пользователя последним может породить ряд проблем:
    1. Как минимум синхронно следует запросить его авторизационные токены, чтобы аутентифицировать пользователя, но что нужно еще? Можно попытаться понять это исходя из того, что за запрос он послал, но запрос может требовать обработки от нескольких сервисов сразу (например он запрашивает список участников группы и сервис Groups должен обратиться в сервис Users) и выяснить что именно нужно может быть нетривиальной задачей.
    2. Объем данных может быть довольно большим.
    3. Пользователь мог попасть на другой Process Unit из-за отказа предыдущего и тогда мы не можем получить данные у отказавшего юнита, а также повторяющиеся попытки и все же вытащить могут помешать восстановлению его работы.
5. Описанное решение достаточно сложно в реализации и потребует много времени на разработку.